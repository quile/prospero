Warnings:
---------
4 shift/reduce conflicts and 1 reduce/reduce conflict

Conflicts:
----------
Conflict in state 138 between rule 149 and token DIV resolved as shift.
Conflict in state 138 between rule 149 and token AND resolved as reduce.
Conflict in state 138 between rule 149 and token BINOP resolved as shift.
Conflict in state 138 between rule 149 and token OR resolved as reduce.
Conflict in state 138 between rule 149 and token '+' resolved as shift.
Conflict in state 138 between rule 149 and token CAT resolved as shift.
Conflict in state 138 between rule 149 and token CMPOP resolved as shift.
Conflict in state 138 between rule 149 and token '?' resolved as reduce.
Conflict in state 138 between rule 149 and token MOD resolved as shift.
Conflict in state 138 between rule 149 and token '/' resolved as shift.
Conflict in state 241 between rule 142 and token DIV resolved as shift.
Conflict in state 241 between rule 142 and token AND resolved as reduce.
Conflict in state 241 between rule 142 and token BINOP resolved as reduce.
Conflict in state 241 between rule 142 and token OR resolved as reduce.
Conflict in state 241 between rule 142 and token '+' resolved as reduce.
Conflict in state 241 between rule 142 and token CAT resolved as reduce.
Conflict in state 241 between rule 142 and token CMPOP resolved as reduce.
Conflict in state 241 between rule 142 and token '?' resolved as reduce.
Conflict in state 241 between rule 142 and token MOD resolved as shift.
Conflict in state 241 between rule 142 and token '/' resolved as shift.
Conflict in state 243 between rule 143 and token DIV resolved as reduce.
Conflict in state 243 between rule 143 and token AND resolved as reduce.
Conflict in state 243 between rule 143 and token BINOP resolved as reduce.
Conflict in state 243 between rule 143 and token OR resolved as reduce.
Conflict in state 243 between rule 143 and token '+' resolved as reduce.
Conflict in state 243 between rule 143 and token CAT resolved as reduce.
Conflict in state 243 between rule 143 and token CMPOP resolved as reduce.
Conflict in state 243 between rule 143 and token '?' resolved as reduce.
Conflict in state 243 between rule 143 and token MOD resolved as shift.
Conflict in state 243 between rule 143 and token '/' resolved as reduce.
Conflict in state 244 between rule 147 and token DIV resolved as shift.
Conflict in state 244 between rule 147 and token AND resolved as reduce.
Conflict in state 244 between rule 147 and token BINOP resolved as shift.
Conflict in state 244 between rule 147 and token OR resolved as reduce.
Conflict in state 244 between rule 147 and token '+' resolved as shift.
Conflict in state 244 between rule 147 and token CAT resolved as shift.
Conflict in state 244 between rule 147 and token CMPOP resolved as shift.
Conflict in state 244 between rule 147 and token '?' resolved as reduce.
Conflict in state 244 between rule 147 and token MOD resolved as shift.
Conflict in state 244 between rule 147 and token '/' resolved as shift.
Conflict in state 245 between rule 140 and token DIV resolved as shift.
Conflict in state 245 between rule 140 and token AND resolved as reduce.
Conflict in state 245 between rule 140 and token BINOP resolved as reduce.
Conflict in state 245 between rule 140 and token OR resolved as reduce.
Conflict in state 245 between rule 140 and token '+' resolved as shift.
Conflict in state 245 between rule 140 and token CAT resolved as reduce.
Conflict in state 245 between rule 140 and token CMPOP resolved as reduce.
Conflict in state 245 between rule 140 and token '?' resolved as reduce.
Conflict in state 245 between rule 140 and token MOD resolved as shift.
Conflict in state 245 between rule 140 and token '/' resolved as shift.
Conflict in state 246 between rule 148 and token DIV resolved as shift.
Conflict in state 246 between rule 148 and token AND resolved as reduce.
Conflict in state 246 between rule 148 and token BINOP resolved as shift.
Conflict in state 246 between rule 148 and token OR resolved as reduce.
Conflict in state 246 between rule 148 and token '+' resolved as shift.
Conflict in state 246 between rule 148 and token CAT resolved as shift.
Conflict in state 246 between rule 148 and token CMPOP resolved as shift.
Conflict in state 246 between rule 148 and token '?' resolved as reduce.
Conflict in state 246 between rule 148 and token MOD resolved as shift.
Conflict in state 246 between rule 148 and token '/' resolved as shift.
Conflict in state 247 between rule 146 and token DIV resolved as shift.
Conflict in state 247 between rule 146 and token AND resolved as reduce.
Conflict in state 247 between rule 146 and token BINOP resolved as shift.
Conflict in state 247 between rule 146 and token OR resolved as reduce.
Conflict in state 247 between rule 146 and token '+' resolved as shift.
Conflict in state 247 between rule 146 and token CAT resolved as reduce.
Conflict in state 247 between rule 146 and token CMPOP resolved as shift.
Conflict in state 247 between rule 146 and token '?' resolved as reduce.
Conflict in state 247 between rule 146 and token MOD resolved as shift.
Conflict in state 247 between rule 146 and token '/' resolved as shift.
Conflict in state 248 between rule 145 and token DIV resolved as shift.
Conflict in state 248 between rule 145 and token AND resolved as reduce.
Conflict in state 248 between rule 145 and token BINOP resolved as shift.
Conflict in state 248 between rule 145 and token OR resolved as reduce.
Conflict in state 248 between rule 145 and token '+' resolved as shift.
Conflict in state 248 between rule 145 and token CAT resolved as reduce.
Conflict in state 248 between rule 145 and token CMPOP resolved as reduce.
Conflict in state 248 between rule 145 and token '?' resolved as reduce.
Conflict in state 248 between rule 145 and token MOD resolved as shift.
Conflict in state 248 between rule 145 and token '/' resolved as shift.
Conflict in state 249 between rule 144 and token DIV resolved as reduce.
Conflict in state 249 between rule 144 and token AND resolved as reduce.
Conflict in state 249 between rule 144 and token BINOP resolved as reduce.
Conflict in state 249 between rule 144 and token OR resolved as reduce.
Conflict in state 249 between rule 144 and token '+' resolved as reduce.
Conflict in state 249 between rule 144 and token CAT resolved as reduce.
Conflict in state 249 between rule 144 and token CMPOP resolved as reduce.
Conflict in state 249 between rule 144 and token '?' resolved as reduce.
Conflict in state 249 between rule 144 and token MOD resolved as reduce.
Conflict in state 249 between rule 144 and token '/' resolved as reduce.
Conflict in state 250 between rule 141 and token DIV resolved as shift.
Conflict in state 250 between rule 141 and token AND resolved as reduce.
Conflict in state 250 between rule 141 and token BINOP resolved as reduce.
Conflict in state 250 between rule 141 and token OR resolved as reduce.
Conflict in state 250 between rule 141 and token '+' resolved as reduce.
Conflict in state 250 between rule 141 and token CAT resolved as reduce.
Conflict in state 250 between rule 141 and token CMPOP resolved as reduce.
Conflict in state 250 between rule 141 and token '?' resolved as reduce.
Conflict in state 250 between rule 141 and token MOD resolved as shift.
Conflict in state 250 between rule 141 and token '/' resolved as reduce.
Conflict in state 326 between rule 150 and token DIV resolved as shift.
Conflict in state 326 between rule 150 and token AND resolved as shift.
Conflict in state 326 between rule 150 and token BINOP resolved as shift.
Conflict in state 326 between rule 150 and token OR resolved as shift.
Conflict in state 326 between rule 150 and token '+' resolved as shift.
Conflict in state 326 between rule 150 and token CAT resolved as shift.
Conflict in state 326 between rule 150 and token CMPOP resolved as shift.
Conflict in state 326 between rule 150 and token '?' resolved as shift.
Conflict in state 326 between rule 150 and token MOD resolved as shift.
Conflict in state 326 between rule 150 and token '/' resolved as shift.
State 40 contains 1 shift/reduce conflict
State 93 contains 1 shift/reduce conflict
State 262 contains 2 shift/reduce conflicts
State 277 contains 1 reduce/reduce conflict

Rules:
------
0:	$start -> template $end
1:	template -> block
2:	block -> chunks
3:	block -> /* empty */
4:	chunks -> chunks chunk
5:	chunks -> chunk
6:	chunk -> TEXT
7:	chunk -> statement ';'
8:	statement -> directive
9:	statement -> defblock
10:	statement -> anonblock
11:	statement -> capture
12:	statement -> macro
13:	statement -> use
14:	statement -> view
15:	statement -> rawperl
16:	statement -> expr
17:	statement -> META metadata
18:	statement -> /* empty */
19:	directive -> setlist
20:	directive -> atomdir
21:	directive -> condition
22:	directive -> switch
23:	directive -> loop
24:	directive -> bind
25:	directive -> try
26:	directive -> perl
27:	atomexpr -> expr
28:	atomexpr -> atomdir
29:	atomdir -> GET expr
30:	atomdir -> CALL expr
31:	atomdir -> SET setlist
32:	atomdir -> DEFAULT setlist
33:	atomdir -> INSERT nameargs
34:	atomdir -> INCLUDE nameargs
35:	atomdir -> PROCESS nameargs
36:	atomdir -> THROW nameargs
37:	atomdir -> RETURN
38:	atomdir -> STOP
39:	atomdir -> CLEAR
40:	atomdir -> LAST
41:	atomdir -> NEXT
42:	atomdir -> DEBUG nameargs
43:	atomdir -> wrapper
44:	atomdir -> filter
45:	condition -> IF expr ';' block else END
46:	condition -> atomexpr IF expr
47:	condition -> UNLESS expr ';' block else END
48:	condition -> atomexpr UNLESS expr
49:	else -> ELSIF expr ';' block else
50:	else -> ELSE ';' block
51:	else -> /* empty */
52:	switch -> SWITCH expr ';' block case END
53:	case -> CASE term ';' block case
54:	case -> CASE DEFAULT ';' block
55:	case -> CASE ';' block
56:	case -> /* empty */
57:	@1-3 -> /* empty */
58:	loop -> FOR loopvar ';' @1-3 block END
59:	loop -> atomexpr FOR loopvar
60:	@2-3 -> /* empty */
61:	loop -> WHILE expr ';' @2-3 block END
62:	loop -> atomexpr WHILE expr
63:	@3-4 -> /* empty */
64:	bind -> BINDING nameargs AROUND ';' @3-4 block END
65:	bind -> BINDING nameargs
66:	@4-4 -> /* empty */
67:	bind -> BIND nameargs AROUND ';' @4-4 block END
68:	bind -> BIND nameargs
69:	loopvar -> IDENT ASSIGN term args
70:	loopvar -> IDENT IN term args
71:	loopvar -> term args
72:	wrapper -> WRAPPER nameargs ';' block END
73:	wrapper -> atomexpr WRAPPER nameargs
74:	try -> TRY ';' block final END
75:	final -> CATCH filename ';' block final
76:	final -> CATCH DEFAULT ';' block final
77:	final -> CATCH ';' block final
78:	final -> FINAL ';' block
79:	final -> /* empty */
80:	use -> USE lnameargs
81:	@5-3 -> /* empty */
82:	view -> VIEW nameargs ';' @5-3 block END
83:	@6-2 -> /* empty */
84:	perl -> PERL ';' @6-2 block END
85:	@7-1 -> /* empty */
86:	rawperl -> RAWPERL @7-1 ';' TEXT END
87:	filter -> FILTER lnameargs ';' block END
88:	filter -> atomexpr FILTER lnameargs
89:	defblock -> defblockname blockargs ';' template END
90:	defblockname -> BLOCK blockname
91:	blockname -> filename
92:	blockname -> LITERAL
93:	blockargs -> metadata
94:	blockargs -> /* empty */
95:	anonblock -> BLOCK blockargs ';' block END
96:	capture -> ident ASSIGN mdir
97:	macro -> MACRO IDENT '(' margs ')' mdir
98:	macro -> MACRO IDENT mdir
99:	mdir -> directive
100:	mdir -> BLOCK ';' block END
101:	margs -> margs IDENT
102:	margs -> margs COMMA
103:	margs -> IDENT
104:	metadata -> metadata meta
105:	metadata -> metadata COMMA
106:	metadata -> meta
107:	meta -> IDENT ASSIGN LITERAL
108:	meta -> IDENT ASSIGN '"' TEXT '"'
109:	meta -> IDENT ASSIGN NUMBER
110:	term -> lterm
111:	term -> sterm
112:	lterm -> '[' list ']'
113:	lterm -> '[' range ']'
114:	lterm -> '[' ']'
115:	lterm -> '{' hash '}'
116:	sterm -> ident
117:	sterm -> REF ident
118:	sterm -> '"' quoted '"'
119:	sterm -> LITERAL
120:	sterm -> NUMBER
121:	list -> list term
122:	list -> list COMMA
123:	list -> term
124:	range -> sterm TO sterm
125:	hash -> params
126:	hash -> /* empty */
127:	params -> params param
128:	params -> params COMMA
129:	params -> param
130:	param -> LITERAL ASSIGN expr
131:	param -> item ASSIGN expr
132:	ident -> ident DOT node
133:	ident -> ident DOT NUMBER
134:	ident -> node
135:	node -> item
136:	node -> item '(' args ')'
137:	item -> IDENT
138:	item -> '${' sterm '}'
139:	item -> '$' IDENT
140:	expr -> expr BINOP expr
141:	expr -> expr '/' expr
142:	expr -> expr '+' expr
143:	expr -> expr DIV expr
144:	expr -> expr MOD expr
145:	expr -> expr CMPOP expr
146:	expr -> expr CAT expr
147:	expr -> expr AND expr
148:	expr -> expr OR expr
149:	expr -> NOT expr
150:	expr -> expr '?' expr ':' expr
151:	expr -> '(' assign ')'
152:	expr -> '(' expr ')'
153:	expr -> term
154:	setlist -> setlist assign
155:	setlist -> setlist COMMA
156:	setlist -> assign
157:	assign -> ident ASSIGN expr
158:	assign -> LITERAL ASSIGN expr
159:	args -> args expr
160:	args -> args param
161:	args -> args ident ASSIGN expr
162:	args -> args COMMA
163:	args -> /* empty */
164:	lnameargs -> lvalue ASSIGN nameargs
165:	lnameargs -> nameargs
166:	lvalue -> item
167:	lvalue -> '"' quoted '"'
168:	lvalue -> LITERAL
169:	nameargs -> '$' ident args
170:	nameargs -> names args
171:	nameargs -> names '(' args ')'
172:	names -> names '+' name
173:	names -> name
174:	name -> '"' quoted '"'
175:	name -> filename
176:	name -> LITERAL
177:	filename -> filename DOT filepart
178:	filename -> filepart
179:	filepart -> FILENAME
180:	filepart -> IDENT
181:	filepart -> NUMBER
182:	quoted -> quoted quotable
183:	quoted -> /* empty */
184:	quotable -> ident
185:	quotable -> TEXT
186:	quotable -> ';'

States:
-------
State 0:

	$start -> . template $end	(Rule 0)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 3 (block)

	item	go to state 40
	loop	go to state 4
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 12
	atomdir	go to state 13
	anonblock	go to state 51
	template	go to state 53
	defblockname	go to state 15
	bind	go to state 54
	ident	go to state 17
	assign	go to state 20
	macro	go to state 21
	lterm	go to state 58
	node	go to state 24
	term	go to state 60
	rawperl	go to state 61
	expr	go to state 64
	use	go to state 65
	defblock	go to state 68
	filter	go to state 30
	sterm	go to state 71
	perl	go to state 32
	chunks	go to state 34
	setlist	go to state 73
	try	go to state 36
	switch	go to state 35
	directive	go to state 74
	block	go to state 75
	condition	go to state 76

State 1:

	atomdir -> SET . setlist	(Rule 31)

	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 78

	setlist	go to state 79
	item	go to state 40
	assign	go to state 20
	node	go to state 24
	ident	go to state 77

State 2:

	item -> IDENT .	(Rule 137)

	$default	reduce using rule 137 (item)

State 3:

	condition -> UNLESS . expr ';' block else END	(Rule 47)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 82
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 4:

	directive -> loop .	(Rule 23)

	$default	reduce using rule 23 (directive)

State 5:

	bind -> BIND . nameargs AROUND ';' @4-4 block END	(Rule 67)
	bind -> BIND . nameargs	(Rule 68)

	'"'	shift, and go to state 91
	'$'	shift, and go to state 88
	FILENAME	shift, and go to state 85
	IDENT	shift, and go to state 83
	LITERAL	shift, and go to state 90
	NUMBER	shift, and go to state 86

	filepart	go to state 89
	names	go to state 93
	nameargs	go to state 92
	filename	go to state 87
	name	go to state 84

State 6:

	chunk -> statement . ';'	(Rule 7)

	';'	shift, and go to state 94

State 7:

	atomdir -> STOP .	(Rule 38)

	$default	reduce using rule 38 (atomdir)

State 8:

	statement -> view .	(Rule 14)

	$default	reduce using rule 14 (statement)

State 9:

	atomdir -> THROW . nameargs	(Rule 36)

	'"'	shift, and go to state 91
	'$'	shift, and go to state 88
	FILENAME	shift, and go to state 85
	IDENT	shift, and go to state 83
	LITERAL	shift, and go to state 90
	NUMBER	shift, and go to state 86

	filepart	go to state 89
	names	go to state 93
	nameargs	go to state 95
	filename	go to state 87
	name	go to state 84

State 10:

	lterm -> '[' . list ']'	(Rule 112)
	lterm -> '[' . range ']'	(Rule 113)
	lterm -> '[' . ']'	(Rule 114)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'['	shift, and go to state 10
	']'	shift, and go to state 98
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	sterm	go to state 100
	item	go to state 40
	range	go to state 97
	node	go to state 24
	ident	go to state 80
	term	go to state 99
	lterm	go to state 58
	list	go to state 96

State 11:

	try -> TRY . ';' block final END	(Rule 74)

	';'	shift, and go to state 101

State 12:

	chunks -> chunk .	(Rule 5)

	$default	reduce using rule 5 (chunks)

State 13:

	directive -> atomdir .	(Rule 20)
	atomexpr -> atomdir .	(Rule 28)

	';'	reduce using rule 20 (directive)
	$default	reduce using rule 28 (atomexpr)

State 14:

	rawperl -> RAWPERL . @7-1 ';' TEXT END	(Rule 86)

	$default	reduce using rule 85 (@7-1)

	@7-1	go to state 102

State 15:

	defblock -> defblockname . blockargs ';' template END	(Rule 89)

	IDENT	shift, and go to state 103

	$default	reduce using rule 94 (blockargs)

	blockargs	go to state 106
	metadata	go to state 105
	meta	go to state 104

State 16:

	statement -> META . metadata	(Rule 17)

	IDENT	shift, and go to state 103

	metadata	go to state 107
	meta	go to state 104

State 17:

	capture -> ident . ASSIGN mdir	(Rule 96)
	sterm -> ident .	(Rule 116)
	ident -> ident . DOT node	(Rule 132)
	ident -> ident . DOT NUMBER	(Rule 133)
	assign -> ident . ASSIGN expr	(Rule 157)

	ASSIGN	shift, and go to state 109
	DOT	shift, and go to state 108

	$default	reduce using rule 116 (sterm)

State 18:

	atomdir -> INCLUDE . nameargs	(Rule 34)

	'"'	shift, and go to state 91
	'$'	shift, and go to state 88
	FILENAME	shift, and go to state 85
	IDENT	shift, and go to state 83
	LITERAL	shift, and go to state 90
	NUMBER	shift, and go to state 86

	filepart	go to state 89
	names	go to state 93
	nameargs	go to state 110
	filename	go to state 87
	name	go to state 84

State 19:

	macro -> MACRO . IDENT '(' margs ')' mdir	(Rule 97)
	macro -> MACRO . IDENT mdir	(Rule 98)

	IDENT	shift, and go to state 111

State 20:

	setlist -> assign .	(Rule 156)

	$default	reduce using rule 156 (setlist)

State 21:

	statement -> macro .	(Rule 12)

	$default	reduce using rule 12 (statement)

State 22:

	loop -> FOR . loopvar ';' @1-3 block END	(Rule 58)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 112
	LITERAL	shift, and go to state 81
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	sterm	go to state 71
	item	go to state 40
	loopvar	go to state 114
	node	go to state 24
	ident	go to state 80
	term	go to state 113
	lterm	go to state 58

State 23:

	atomdir -> NEXT .	(Rule 41)

	$default	reduce using rule 41 (atomdir)

State 24:

	ident -> node .	(Rule 134)

	$default	reduce using rule 134 (ident)

State 25:

	chunk -> TEXT .	(Rule 6)

	$default	reduce using rule 6 (chunk)

State 26:

	filter -> FILTER . lnameargs ';' block END	(Rule 87)

	'"'	shift, and go to state 121
	'$'	shift, and go to state 118
	'${'	shift, and go to state 38
	FILENAME	shift, and go to state 85
	IDENT	shift, and go to state 115
	LITERAL	shift, and go to state 120
	NUMBER	shift, and go to state 86

	names	go to state 93
	lvalue	go to state 116
	item	go to state 117
	name	go to state 84
	filepart	go to state 89
	filename	go to state 87
	nameargs	go to state 122
	lnameargs	go to state 119

State 27:

	sterm -> NUMBER .	(Rule 120)

	$default	reduce using rule 120 (sterm)

State 28:

	sterm -> REF . ident	(Rule 117)

	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	IDENT	shift, and go to state 2

	item	go to state 40
	node	go to state 24
	ident	go to state 123

State 29:

	defblockname -> BLOCK . blockname	(Rule 90)
	anonblock -> BLOCK . blockargs ';' block END	(Rule 95)

	FILENAME	shift, and go to state 85
	IDENT	shift, and go to state 124
	LITERAL	shift, and go to state 128
	NUMBER	shift, and go to state 86

	$default	reduce using rule 94 (blockargs)

	blockargs	go to state 127
	filepart	go to state 89
	filename	go to state 126
	blockname	go to state 125
	metadata	go to state 105
	meta	go to state 104

State 30:

	atomdir -> filter .	(Rule 44)

	$default	reduce using rule 44 (atomdir)

State 31:

	lterm -> '{' . hash '}'	(Rule 115)

	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 133

	$default	reduce using rule 126 (hash)

	params	go to state 132
	hash	go to state 129
	item	go to state 130
	param	go to state 131

State 32:

	directive -> perl .	(Rule 26)

	$default	reduce using rule 26 (directive)

State 33:

	use -> USE . lnameargs	(Rule 80)

	'"'	shift, and go to state 121
	'$'	shift, and go to state 118
	'${'	shift, and go to state 38
	FILENAME	shift, and go to state 85
	IDENT	shift, and go to state 115
	LITERAL	shift, and go to state 120
	NUMBER	shift, and go to state 86

	names	go to state 93
	lvalue	go to state 116
	item	go to state 117
	name	go to state 84
	filepart	go to state 89
	filename	go to state 87
	nameargs	go to state 122
	lnameargs	go to state 134

State 34:

	block -> chunks .	(Rule 2)
	chunks -> chunks . chunk	(Rule 4)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 2 (block)

	item	go to state 40
	node	go to state 24
	rawperl	go to state 61
	term	go to state 60
	loop	go to state 4
	use	go to state 65
	expr	go to state 64
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 135
	defblock	go to state 68
	atomdir	go to state 13
	anonblock	go to state 51
	sterm	go to state 71
	defblockname	go to state 15
	filter	go to state 30
	bind	go to state 54
	ident	go to state 17
	perl	go to state 32
	setlist	go to state 73
	try	go to state 36
	switch	go to state 35
	assign	go to state 20
	directive	go to state 74
	macro	go to state 21
	condition	go to state 76
	lterm	go to state 58

State 35:

	directive -> switch .	(Rule 22)

	$default	reduce using rule 22 (directive)

State 36:

	directive -> try .	(Rule 25)

	$default	reduce using rule 25 (directive)

State 37:

	view -> VIEW . nameargs ';' @5-3 block END	(Rule 82)

	'"'	shift, and go to state 91
	'$'	shift, and go to state 88
	FILENAME	shift, and go to state 85
	IDENT	shift, and go to state 83
	LITERAL	shift, and go to state 90
	NUMBER	shift, and go to state 86

	filepart	go to state 89
	names	go to state 93
	nameargs	go to state 136
	filename	go to state 87
	name	go to state 84

State 38:

	item -> '${' . sterm '}'	(Rule 138)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	sterm	go to state 137
	item	go to state 40
	node	go to state 24
	ident	go to state 80

State 39:

	expr -> NOT . expr	(Rule 149)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 138
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 40:

	node -> item .	(Rule 135)
	node -> item . '(' args ')'	(Rule 136)

	'('	shift, and go to state 139

	'('	[reduce using rule 135 (node)]
	$default	reduce using rule 135 (node)

State 41:

	perl -> PERL . ';' @6-2 block END	(Rule 84)

	';'	shift, and go to state 140

State 42:

	atomdir -> CLEAR .	(Rule 39)

	$default	reduce using rule 39 (atomdir)

State 43:

	statement -> capture .	(Rule 11)

	$default	reduce using rule 11 (statement)

State 44:

	item -> '$' . IDENT	(Rule 139)

	IDENT	shift, and go to state 141

State 45:

	condition -> IF . expr ';' block else END	(Rule 45)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 142
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 46:

	atomdir -> CALL . expr	(Rule 30)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 143
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 47:

	atomdir -> wrapper .	(Rule 43)

	$default	reduce using rule 43 (atomdir)

State 48:

	atomdir -> GET . expr	(Rule 29)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 144
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 49:

	condition -> atomexpr . IF expr	(Rule 46)
	condition -> atomexpr . UNLESS expr	(Rule 48)
	loop -> atomexpr . FOR loopvar	(Rule 59)
	loop -> atomexpr . WHILE expr	(Rule 62)
	wrapper -> atomexpr . WRAPPER nameargs	(Rule 73)
	filter -> atomexpr . FILTER lnameargs	(Rule 88)

	FILTER	shift, and go to state 147
	FOR	shift, and go to state 146
	IF	shift, and go to state 148
	UNLESS	shift, and go to state 145
	WHILE	shift, and go to state 150
	WRAPPER	shift, and go to state 149

State 50:

	atomdir -> LAST .	(Rule 40)

	$default	reduce using rule 40 (atomdir)

State 51:

	statement -> anonblock .	(Rule 10)

	$default	reduce using rule 10 (statement)

State 52:

	atomdir -> DEBUG . nameargs	(Rule 42)

	'"'	shift, and go to state 91
	'$'	shift, and go to state 88
	FILENAME	shift, and go to state 85
	IDENT	shift, and go to state 83
	LITERAL	shift, and go to state 90
	NUMBER	shift, and go to state 86

	filepart	go to state 89
	names	go to state 93
	nameargs	go to state 151
	filename	go to state 87
	name	go to state 84

State 53:

	$start -> template . $end	(Rule 0)

	$end	shift, and go to state 152

State 54:

	directive -> bind .	(Rule 24)

	$default	reduce using rule 24 (directive)

State 55:

	expr -> '(' . assign ')'	(Rule 151)
	expr -> '(' . expr ')'	(Rule 152)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 59
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 155
	sterm	go to state 71
	item	go to state 40
	assign	go to state 154
	node	go to state 24
	ident	go to state 153
	term	go to state 60
	lterm	go to state 58

State 56:

	switch -> SWITCH . expr ';' block case END	(Rule 52)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 156
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 57:

	wrapper -> WRAPPER . nameargs ';' block END	(Rule 72)

	'"'	shift, and go to state 91
	'$'	shift, and go to state 88
	FILENAME	shift, and go to state 85
	IDENT	shift, and go to state 83
	LITERAL	shift, and go to state 90
	NUMBER	shift, and go to state 86

	filepart	go to state 89
	names	go to state 93
	nameargs	go to state 157
	filename	go to state 87
	name	go to state 84

State 58:

	term -> lterm .	(Rule 110)

	$default	reduce using rule 110 (term)

State 59:

	sterm -> LITERAL .	(Rule 119)
	assign -> LITERAL . ASSIGN expr	(Rule 158)

	ASSIGN	shift, and go to state 158

	$default	reduce using rule 119 (sterm)

State 60:

	expr -> term .	(Rule 153)

	$default	reduce using rule 153 (expr)

State 61:

	statement -> rawperl .	(Rule 15)

	$default	reduce using rule 15 (statement)

State 62:

	sterm -> '"' . quoted '"'	(Rule 118)

	$default	reduce using rule 183 (quoted)

	quoted	go to state 159

State 63:

	atomdir -> PROCESS . nameargs	(Rule 35)

	'"'	shift, and go to state 91
	'$'	shift, and go to state 88
	FILENAME	shift, and go to state 85
	IDENT	shift, and go to state 83
	LITERAL	shift, and go to state 90
	NUMBER	shift, and go to state 86

	filepart	go to state 89
	names	go to state 93
	nameargs	go to state 160
	filename	go to state 87
	name	go to state 84

State 64:

	statement -> expr .	(Rule 16)
	atomexpr -> expr .	(Rule 27)
	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	'?'	shift, and go to state 162
	AND	shift, and go to state 164
	BINOP	shift, and go to state 165
	CAT	shift, and go to state 167
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169
	OR	shift, and go to state 166

	';'	reduce using rule 16 (statement)
	$default	reduce using rule 27 (atomexpr)

State 65:

	statement -> use .	(Rule 13)

	$default	reduce using rule 13 (statement)

State 66:

	atomdir -> RETURN .	(Rule 37)

	$default	reduce using rule 37 (atomdir)

State 67:

	atomdir -> INSERT . nameargs	(Rule 33)

	'"'	shift, and go to state 91
	'$'	shift, and go to state 88
	FILENAME	shift, and go to state 85
	IDENT	shift, and go to state 83
	LITERAL	shift, and go to state 90
	NUMBER	shift, and go to state 86

	filepart	go to state 89
	names	go to state 93
	nameargs	go to state 171
	filename	go to state 87
	name	go to state 84

State 68:

	statement -> defblock .	(Rule 9)

	$default	reduce using rule 9 (statement)

State 69:

	bind -> BINDING . nameargs AROUND ';' @3-4 block END	(Rule 64)
	bind -> BINDING . nameargs	(Rule 65)

	'"'	shift, and go to state 91
	'$'	shift, and go to state 88
	FILENAME	shift, and go to state 85
	IDENT	shift, and go to state 83
	LITERAL	shift, and go to state 90
	NUMBER	shift, and go to state 86

	filepart	go to state 89
	names	go to state 93
	nameargs	go to state 172
	filename	go to state 87
	name	go to state 84

State 70:

	loop -> WHILE . expr ';' @2-3 block END	(Rule 61)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 173
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 71:

	term -> sterm .	(Rule 111)

	$default	reduce using rule 111 (term)

State 72:

	atomdir -> DEFAULT . setlist	(Rule 32)

	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 78

	setlist	go to state 174
	item	go to state 40
	assign	go to state 20
	node	go to state 24
	ident	go to state 77

State 73:

	directive -> setlist .	(Rule 19)
	setlist -> setlist . assign	(Rule 154)
	setlist -> setlist . COMMA	(Rule 155)

	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	COMMA	shift, and go to state 176
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 78

	$default	reduce using rule 19 (directive)

	item	go to state 40
	assign	go to state 175
	node	go to state 24
	ident	go to state 77

State 74:

	statement -> directive .	(Rule 8)

	$default	reduce using rule 8 (statement)

State 75:

	template -> block .	(Rule 1)

	$default	reduce using rule 1 (template)

State 76:

	directive -> condition .	(Rule 21)

	$default	reduce using rule 21 (directive)

State 77:

	ident -> ident . DOT node	(Rule 132)
	ident -> ident . DOT NUMBER	(Rule 133)
	assign -> ident . ASSIGN expr	(Rule 157)

	ASSIGN	shift, and go to state 177
	DOT	shift, and go to state 108

State 78:

	assign -> LITERAL . ASSIGN expr	(Rule 158)

	ASSIGN	shift, and go to state 158

State 79:

	atomdir -> SET setlist .	(Rule 31)
	setlist -> setlist . assign	(Rule 154)
	setlist -> setlist . COMMA	(Rule 155)

	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	COMMA	shift, and go to state 176
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 78

	$default	reduce using rule 31 (atomdir)

	item	go to state 40
	assign	go to state 175
	node	go to state 24
	ident	go to state 77

State 80:

	sterm -> ident .	(Rule 116)
	ident -> ident . DOT node	(Rule 132)
	ident -> ident . DOT NUMBER	(Rule 133)

	DOT	shift, and go to state 108

	$default	reduce using rule 116 (sterm)

State 81:

	sterm -> LITERAL .	(Rule 119)

	$default	reduce using rule 119 (sterm)

State 82:

	condition -> UNLESS expr . ';' block else END	(Rule 47)
	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	';'	shift, and go to state 178
	'?'	shift, and go to state 162
	AND	shift, and go to state 164
	BINOP	shift, and go to state 165
	CAT	shift, and go to state 167
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169
	OR	shift, and go to state 166

State 83:

	filepart -> IDENT .	(Rule 180)

	$default	reduce using rule 180 (filepart)

State 84:

	names -> name .	(Rule 173)

	$default	reduce using rule 173 (names)

State 85:

	filepart -> FILENAME .	(Rule 179)

	$default	reduce using rule 179 (filepart)

State 86:

	filepart -> NUMBER .	(Rule 181)

	$default	reduce using rule 181 (filepart)

State 87:

	name -> filename .	(Rule 175)
	filename -> filename . DOT filepart	(Rule 177)

	DOT	shift, and go to state 179

	$default	reduce using rule 175 (name)

State 88:

	nameargs -> '$' . ident args	(Rule 169)

	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	IDENT	shift, and go to state 2

	item	go to state 40
	node	go to state 24
	ident	go to state 180

State 89:

	filename -> filepart .	(Rule 178)

	$default	reduce using rule 178 (filename)

State 90:

	name -> LITERAL .	(Rule 176)

	$default	reduce using rule 176 (name)

State 91:

	name -> '"' . quoted '"'	(Rule 174)

	$default	reduce using rule 183 (quoted)

	quoted	go to state 181

State 92:

	bind -> BIND nameargs . AROUND ';' @4-4 block END	(Rule 67)
	bind -> BIND nameargs .	(Rule 68)

	AROUND	shift, and go to state 182

	$default	reduce using rule 68 (bind)

State 93:

	nameargs -> names . args	(Rule 170)
	nameargs -> names . '(' args ')'	(Rule 171)
	names -> names . '+' name	(Rule 172)

	'('	shift, and go to state 184
	'+'	shift, and go to state 183

	'('	[reduce using rule 163 (args)]
	$default	reduce using rule 163 (args)

	args	go to state 185

State 94:

	chunk -> statement ';' .	(Rule 7)

	$default	reduce using rule 7 (chunk)

State 95:

	atomdir -> THROW nameargs .	(Rule 36)

	$default	reduce using rule 36 (atomdir)

State 96:

	lterm -> '[' list . ']'	(Rule 112)
	list -> list . term	(Rule 121)
	list -> list . COMMA	(Rule 122)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'['	shift, and go to state 10
	']'	shift, and go to state 186
	'{'	shift, and go to state 31
	COMMA	shift, and go to state 188
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 187
	lterm	go to state 58

State 97:

	lterm -> '[' range . ']'	(Rule 113)

	']'	shift, and go to state 189

State 98:

	lterm -> '[' ']' .	(Rule 114)

	$default	reduce using rule 114 (lterm)

State 99:

	list -> term .	(Rule 123)

	$default	reduce using rule 123 (list)

State 100:

	term -> sterm .	(Rule 111)
	range -> sterm . TO sterm	(Rule 124)

	TO	shift, and go to state 190

	$default	reduce using rule 111 (term)

State 101:

	try -> TRY ';' . block final END	(Rule 74)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 3 (block)

	item	go to state 40
	loop	go to state 4
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 12
	atomdir	go to state 13
	anonblock	go to state 51
	defblockname	go to state 15
	bind	go to state 54
	ident	go to state 17
	assign	go to state 20
	macro	go to state 21
	lterm	go to state 58
	node	go to state 24
	term	go to state 60
	rawperl	go to state 61
	expr	go to state 64
	use	go to state 65
	defblock	go to state 68
	filter	go to state 30
	sterm	go to state 71
	perl	go to state 32
	chunks	go to state 34
	setlist	go to state 73
	switch	go to state 35
	try	go to state 36
	directive	go to state 74
	block	go to state 191
	condition	go to state 76

State 102:

	rawperl -> RAWPERL @7-1 . ';' TEXT END	(Rule 86)

	';'	shift, and go to state 192

State 103:

	meta -> IDENT . ASSIGN LITERAL	(Rule 107)
	meta -> IDENT . ASSIGN '"' TEXT '"'	(Rule 108)
	meta -> IDENT . ASSIGN NUMBER	(Rule 109)

	ASSIGN	shift, and go to state 193

State 104:

	metadata -> meta .	(Rule 106)

	$default	reduce using rule 106 (metadata)

State 105:

	blockargs -> metadata .	(Rule 93)
	metadata -> metadata . meta	(Rule 104)
	metadata -> metadata . COMMA	(Rule 105)

	COMMA	shift, and go to state 195
	IDENT	shift, and go to state 103

	$default	reduce using rule 93 (blockargs)

	meta	go to state 194

State 106:

	defblock -> defblockname blockargs . ';' template END	(Rule 89)

	';'	shift, and go to state 196

State 107:

	statement -> META metadata .	(Rule 17)
	metadata -> metadata . meta	(Rule 104)
	metadata -> metadata . COMMA	(Rule 105)

	COMMA	shift, and go to state 195
	IDENT	shift, and go to state 103

	$default	reduce using rule 17 (statement)

	meta	go to state 194

State 108:

	ident -> ident DOT . node	(Rule 132)
	ident -> ident DOT . NUMBER	(Rule 133)

	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	IDENT	shift, and go to state 2
	NUMBER	shift, and go to state 198

	item	go to state 40
	node	go to state 197

State 109:

	capture -> ident ASSIGN . mdir	(Rule 96)
	assign -> ident ASSIGN . expr	(Rule 157)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 199
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	item	go to state 40
	node	go to state 24
	term	go to state 60
	loop	go to state 4
	expr	go to state 201
	wrapper	go to state 47
	atomexpr	go to state 49
	atomdir	go to state 13
	mdir	go to state 200
	sterm	go to state 71
	filter	go to state 30
	bind	go to state 54
	ident	go to state 153
	perl	go to state 32
	setlist	go to state 73
	try	go to state 36
	switch	go to state 35
	assign	go to state 20
	directive	go to state 202
	condition	go to state 76
	lterm	go to state 58

State 110:

	atomdir -> INCLUDE nameargs .	(Rule 34)

	$default	reduce using rule 34 (atomdir)

State 111:

	macro -> MACRO IDENT . '(' margs ')' mdir	(Rule 97)
	macro -> MACRO IDENT . mdir	(Rule 98)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 204
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 199
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	item	go to state 40
	node	go to state 24
	term	go to state 60
	loop	go to state 4
	expr	go to state 205
	wrapper	go to state 47
	atomexpr	go to state 49
	atomdir	go to state 13
	mdir	go to state 203
	sterm	go to state 71
	filter	go to state 30
	bind	go to state 54
	ident	go to state 153
	perl	go to state 32
	setlist	go to state 73
	try	go to state 36
	switch	go to state 35
	assign	go to state 20
	directive	go to state 202
	condition	go to state 76
	lterm	go to state 58

State 112:

	loopvar -> IDENT . ASSIGN term args	(Rule 69)
	loopvar -> IDENT . IN term args	(Rule 70)
	item -> IDENT .	(Rule 137)

	ASSIGN	shift, and go to state 206
	IN	shift, and go to state 207

	$default	reduce using rule 137 (item)

State 113:

	loopvar -> term . args	(Rule 71)

	$default	reduce using rule 163 (args)

	args	go to state 208

State 114:

	loop -> FOR loopvar . ';' @1-3 block END	(Rule 58)

	';'	shift, and go to state 209

State 115:

	item -> IDENT .	(Rule 137)
	filepart -> IDENT .	(Rule 180)

	ASSIGN	reduce using rule 137 (item)
	$default	reduce using rule 180 (filepart)

State 116:

	lnameargs -> lvalue . ASSIGN nameargs	(Rule 164)

	ASSIGN	shift, and go to state 210

State 117:

	lvalue -> item .	(Rule 166)

	$default	reduce using rule 166 (lvalue)

State 118:

	item -> '$' . IDENT	(Rule 139)
	nameargs -> '$' . ident args	(Rule 169)

	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	IDENT	shift, and go to state 211

	item	go to state 40
	node	go to state 24
	ident	go to state 180

State 119:

	filter -> FILTER lnameargs . ';' block END	(Rule 87)

	';'	shift, and go to state 212

State 120:

	lvalue -> LITERAL .	(Rule 168)
	name -> LITERAL .	(Rule 176)

	ASSIGN	reduce using rule 168 (lvalue)
	$default	reduce using rule 176 (name)

State 121:

	lvalue -> '"' . quoted '"'	(Rule 167)
	name -> '"' . quoted '"'	(Rule 174)

	$default	reduce using rule 183 (quoted)

	quoted	go to state 213

State 122:

	lnameargs -> nameargs .	(Rule 165)

	$default	reduce using rule 165 (lnameargs)

State 123:

	sterm -> REF ident .	(Rule 117)
	ident -> ident . DOT node	(Rule 132)
	ident -> ident . DOT NUMBER	(Rule 133)

	DOT	shift, and go to state 108

	$default	reduce using rule 117 (sterm)

State 124:

	meta -> IDENT . ASSIGN LITERAL	(Rule 107)
	meta -> IDENT . ASSIGN '"' TEXT '"'	(Rule 108)
	meta -> IDENT . ASSIGN NUMBER	(Rule 109)
	filepart -> IDENT .	(Rule 180)

	ASSIGN	shift, and go to state 193

	$default	reduce using rule 180 (filepart)

State 125:

	defblockname -> BLOCK blockname .	(Rule 90)

	$default	reduce using rule 90 (defblockname)

State 126:

	blockname -> filename .	(Rule 91)
	filename -> filename . DOT filepart	(Rule 177)

	DOT	shift, and go to state 179

	$default	reduce using rule 91 (blockname)

State 127:

	anonblock -> BLOCK blockargs . ';' block END	(Rule 95)

	';'	shift, and go to state 214

State 128:

	blockname -> LITERAL .	(Rule 92)

	$default	reduce using rule 92 (blockname)

State 129:

	lterm -> '{' hash . '}'	(Rule 115)

	'}'	shift, and go to state 215

State 130:

	param -> item . ASSIGN expr	(Rule 131)

	ASSIGN	shift, and go to state 216

State 131:

	params -> param .	(Rule 129)

	$default	reduce using rule 129 (params)

State 132:

	hash -> params .	(Rule 125)
	params -> params . param	(Rule 127)
	params -> params . COMMA	(Rule 128)

	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	COMMA	shift, and go to state 218
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 133

	$default	reduce using rule 125 (hash)

	item	go to state 130
	param	go to state 217

State 133:

	param -> LITERAL . ASSIGN expr	(Rule 130)

	ASSIGN	shift, and go to state 219

State 134:

	use -> USE lnameargs .	(Rule 80)

	$default	reduce using rule 80 (use)

State 135:

	chunks -> chunks chunk .	(Rule 4)

	$default	reduce using rule 4 (chunks)

State 136:

	view -> VIEW nameargs . ';' @5-3 block END	(Rule 82)

	';'	shift, and go to state 220

State 137:

	item -> '${' sterm . '}'	(Rule 138)

	'}'	shift, and go to state 221

State 138:

	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> NOT expr .	(Rule 149)
	expr -> expr . '?' expr ':' expr	(Rule 150)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	BINOP	shift, and go to state 165
	CAT	shift, and go to state 167
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169

	$default	reduce using rule 149 (expr)

State 139:

	node -> item '(' . args ')'	(Rule 136)

	$default	reduce using rule 163 (args)

	args	go to state 222

State 140:

	perl -> PERL ';' . @6-2 block END	(Rule 84)

	$default	reduce using rule 83 (@6-2)

	@6-2	go to state 223

State 141:

	item -> '$' IDENT .	(Rule 139)

	$default	reduce using rule 139 (item)

State 142:

	condition -> IF expr . ';' block else END	(Rule 45)
	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	';'	shift, and go to state 224
	'?'	shift, and go to state 162
	AND	shift, and go to state 164
	BINOP	shift, and go to state 165
	CAT	shift, and go to state 167
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169
	OR	shift, and go to state 166

State 143:

	atomdir -> CALL expr .	(Rule 30)
	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	'?'	shift, and go to state 162
	AND	shift, and go to state 164
	BINOP	shift, and go to state 165
	CAT	shift, and go to state 167
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169
	OR	shift, and go to state 166

	$default	reduce using rule 30 (atomdir)

State 144:

	atomdir -> GET expr .	(Rule 29)
	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	'?'	shift, and go to state 162
	AND	shift, and go to state 164
	BINOP	shift, and go to state 165
	CAT	shift, and go to state 167
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169
	OR	shift, and go to state 166

	$default	reduce using rule 29 (atomdir)

State 145:

	condition -> atomexpr UNLESS . expr	(Rule 48)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 225
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 146:

	loop -> atomexpr FOR . loopvar	(Rule 59)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 112
	LITERAL	shift, and go to state 81
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	sterm	go to state 71
	item	go to state 40
	loopvar	go to state 226
	node	go to state 24
	ident	go to state 80
	term	go to state 113
	lterm	go to state 58

State 147:

	filter -> atomexpr FILTER . lnameargs	(Rule 88)

	'"'	shift, and go to state 121
	'$'	shift, and go to state 118
	'${'	shift, and go to state 38
	FILENAME	shift, and go to state 85
	IDENT	shift, and go to state 115
	LITERAL	shift, and go to state 120
	NUMBER	shift, and go to state 86

	names	go to state 93
	lvalue	go to state 116
	item	go to state 117
	name	go to state 84
	filepart	go to state 89
	filename	go to state 87
	nameargs	go to state 122
	lnameargs	go to state 227

State 148:

	condition -> atomexpr IF . expr	(Rule 46)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 228
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 149:

	wrapper -> atomexpr WRAPPER . nameargs	(Rule 73)

	'"'	shift, and go to state 91
	'$'	shift, and go to state 88
	FILENAME	shift, and go to state 85
	IDENT	shift, and go to state 83
	LITERAL	shift, and go to state 90
	NUMBER	shift, and go to state 86

	filepart	go to state 89
	names	go to state 93
	nameargs	go to state 229
	filename	go to state 87
	name	go to state 84

State 150:

	loop -> atomexpr WHILE . expr	(Rule 62)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 230
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 151:

	atomdir -> DEBUG nameargs .	(Rule 42)

	$default	reduce using rule 42 (atomdir)

State 152:

	$start -> template $end .	(Rule 0)

	$default	accept

State 153:

	sterm -> ident .	(Rule 116)
	ident -> ident . DOT node	(Rule 132)
	ident -> ident . DOT NUMBER	(Rule 133)
	assign -> ident . ASSIGN expr	(Rule 157)

	ASSIGN	shift, and go to state 177
	DOT	shift, and go to state 108

	$default	reduce using rule 116 (sterm)

State 154:

	expr -> '(' assign . ')'	(Rule 151)

	')'	shift, and go to state 231

State 155:

	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)
	expr -> '(' expr . ')'	(Rule 152)

	')'	shift, and go to state 232
	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	'?'	shift, and go to state 162
	AND	shift, and go to state 164
	BINOP	shift, and go to state 165
	CAT	shift, and go to state 167
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169
	OR	shift, and go to state 166

State 156:

	switch -> SWITCH expr . ';' block case END	(Rule 52)
	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	';'	shift, and go to state 233
	'?'	shift, and go to state 162
	AND	shift, and go to state 164
	BINOP	shift, and go to state 165
	CAT	shift, and go to state 167
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169
	OR	shift, and go to state 166

State 157:

	wrapper -> WRAPPER nameargs . ';' block END	(Rule 72)

	';'	shift, and go to state 234

State 158:

	assign -> LITERAL ASSIGN . expr	(Rule 158)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 235
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 159:

	sterm -> '"' quoted . '"'	(Rule 118)
	quoted -> quoted . quotable	(Rule 182)

	'"'	shift, and go to state 240
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	';'	shift, and go to state 239
	IDENT	shift, and go to state 2
	TEXT	shift, and go to state 237

	item	go to state 40
	node	go to state 24
	ident	go to state 236
	quotable	go to state 238

State 160:

	atomdir -> PROCESS nameargs .	(Rule 35)

	$default	reduce using rule 35 (atomdir)

State 161:

	expr -> expr '+' . expr	(Rule 142)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 241
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 162:

	expr -> expr '?' . expr ':' expr	(Rule 150)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 242
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 163:

	expr -> expr DIV . expr	(Rule 143)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 243
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 164:

	expr -> expr AND . expr	(Rule 147)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 244
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 165:

	expr -> expr BINOP . expr	(Rule 140)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 245
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 166:

	expr -> expr OR . expr	(Rule 148)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 246
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 167:

	expr -> expr CAT . expr	(Rule 146)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 247
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 168:

	expr -> expr CMPOP . expr	(Rule 145)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 248
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 169:

	expr -> expr MOD . expr	(Rule 144)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 249
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 170:

	expr -> expr '/' . expr	(Rule 141)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 250
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 171:

	atomdir -> INSERT nameargs .	(Rule 33)

	$default	reduce using rule 33 (atomdir)

State 172:

	bind -> BINDING nameargs . AROUND ';' @3-4 block END	(Rule 64)
	bind -> BINDING nameargs .	(Rule 65)

	AROUND	shift, and go to state 251

	$default	reduce using rule 65 (bind)

State 173:

	loop -> WHILE expr . ';' @2-3 block END	(Rule 61)
	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	';'	shift, and go to state 252
	'?'	shift, and go to state 162
	AND	shift, and go to state 164
	BINOP	shift, and go to state 165
	CAT	shift, and go to state 167
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169
	OR	shift, and go to state 166

State 174:

	atomdir -> DEFAULT setlist .	(Rule 32)
	setlist -> setlist . assign	(Rule 154)
	setlist -> setlist . COMMA	(Rule 155)

	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	COMMA	shift, and go to state 176
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 78

	$default	reduce using rule 32 (atomdir)

	item	go to state 40
	assign	go to state 175
	node	go to state 24
	ident	go to state 77

State 175:

	setlist -> setlist assign .	(Rule 154)

	$default	reduce using rule 154 (setlist)

State 176:

	setlist -> setlist COMMA .	(Rule 155)

	$default	reduce using rule 155 (setlist)

State 177:

	assign -> ident ASSIGN . expr	(Rule 157)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 253
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 178:

	condition -> UNLESS expr ';' . block else END	(Rule 47)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 3 (block)

	item	go to state 40
	loop	go to state 4
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 12
	atomdir	go to state 13
	anonblock	go to state 51
	defblockname	go to state 15
	bind	go to state 54
	ident	go to state 17
	assign	go to state 20
	macro	go to state 21
	lterm	go to state 58
	node	go to state 24
	term	go to state 60
	rawperl	go to state 61
	expr	go to state 64
	use	go to state 65
	defblock	go to state 68
	filter	go to state 30
	sterm	go to state 71
	perl	go to state 32
	chunks	go to state 34
	setlist	go to state 73
	switch	go to state 35
	try	go to state 36
	directive	go to state 74
	block	go to state 254
	condition	go to state 76

State 179:

	filename -> filename DOT . filepart	(Rule 177)

	FILENAME	shift, and go to state 85
	IDENT	shift, and go to state 83
	NUMBER	shift, and go to state 86

	filepart	go to state 255

State 180:

	ident -> ident . DOT node	(Rule 132)
	ident -> ident . DOT NUMBER	(Rule 133)
	nameargs -> '$' ident . args	(Rule 169)

	DOT	shift, and go to state 108

	$default	reduce using rule 163 (args)

	args	go to state 256

State 181:

	name -> '"' quoted . '"'	(Rule 174)
	quoted -> quoted . quotable	(Rule 182)

	'"'	shift, and go to state 257
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	';'	shift, and go to state 239
	IDENT	shift, and go to state 2
	TEXT	shift, and go to state 237

	item	go to state 40
	node	go to state 24
	ident	go to state 236
	quotable	go to state 238

State 182:

	bind -> BIND nameargs AROUND . ';' @4-4 block END	(Rule 67)

	';'	shift, and go to state 258

State 183:

	names -> names '+' . name	(Rule 172)

	'"'	shift, and go to state 91
	FILENAME	shift, and go to state 85
	IDENT	shift, and go to state 83
	LITERAL	shift, and go to state 90
	NUMBER	shift, and go to state 86

	filepart	go to state 89
	filename	go to state 87
	name	go to state 259

State 184:

	nameargs -> names '(' . args ')'	(Rule 171)

	$default	reduce using rule 163 (args)

	args	go to state 260

State 185:

	args -> args . expr	(Rule 159)
	args -> args . param	(Rule 160)
	args -> args . ident ASSIGN expr	(Rule 161)
	args -> args . COMMA	(Rule 162)
	nameargs -> names args .	(Rule 170)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	COMMA	shift, and go to state 266
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 264
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	$default	reduce using rule 170 (nameargs)

	expr	go to state 265
	sterm	go to state 71
	item	go to state 262
	param	go to state 263
	node	go to state 24
	ident	go to state 261
	term	go to state 60
	lterm	go to state 58

State 186:

	lterm -> '[' list ']' .	(Rule 112)

	$default	reduce using rule 112 (lterm)

State 187:

	list -> list term .	(Rule 121)

	$default	reduce using rule 121 (list)

State 188:

	list -> list COMMA .	(Rule 122)

	$default	reduce using rule 122 (list)

State 189:

	lterm -> '[' range ']' .	(Rule 113)

	$default	reduce using rule 113 (lterm)

State 190:

	range -> sterm TO . sterm	(Rule 124)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	sterm	go to state 267
	item	go to state 40
	node	go to state 24
	ident	go to state 80

State 191:

	try -> TRY ';' block . final END	(Rule 74)

	CATCH	shift, and go to state 270
	FINAL	shift, and go to state 268

	$default	reduce using rule 79 (final)

	final	go to state 269

State 192:

	rawperl -> RAWPERL @7-1 ';' . TEXT END	(Rule 86)

	TEXT	shift, and go to state 271

State 193:

	meta -> IDENT ASSIGN . LITERAL	(Rule 107)
	meta -> IDENT ASSIGN . '"' TEXT '"'	(Rule 108)
	meta -> IDENT ASSIGN . NUMBER	(Rule 109)

	'"'	shift, and go to state 274
	LITERAL	shift, and go to state 273
	NUMBER	shift, and go to state 272

State 194:

	metadata -> metadata meta .	(Rule 104)

	$default	reduce using rule 104 (metadata)

State 195:

	metadata -> metadata COMMA .	(Rule 105)

	$default	reduce using rule 105 (metadata)

State 196:

	defblock -> defblockname blockargs ';' . template END	(Rule 89)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 3 (block)

	item	go to state 40
	loop	go to state 4
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 12
	atomdir	go to state 13
	anonblock	go to state 51
	template	go to state 275
	defblockname	go to state 15
	bind	go to state 54
	ident	go to state 17
	assign	go to state 20
	macro	go to state 21
	lterm	go to state 58
	node	go to state 24
	term	go to state 60
	rawperl	go to state 61
	expr	go to state 64
	use	go to state 65
	defblock	go to state 68
	filter	go to state 30
	sterm	go to state 71
	perl	go to state 32
	chunks	go to state 34
	setlist	go to state 73
	switch	go to state 35
	try	go to state 36
	directive	go to state 74
	block	go to state 75
	condition	go to state 76

State 197:

	ident -> ident DOT node .	(Rule 132)

	$default	reduce using rule 132 (ident)

State 198:

	ident -> ident DOT NUMBER .	(Rule 133)

	$default	reduce using rule 133 (ident)

State 199:

	mdir -> BLOCK . ';' block END	(Rule 100)

	';'	shift, and go to state 276

State 200:

	capture -> ident ASSIGN mdir .	(Rule 96)

	$default	reduce using rule 96 (capture)

State 201:

	atomexpr -> expr .	(Rule 27)
	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)
	assign -> ident ASSIGN expr .	(Rule 157)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	'?'	shift, and go to state 162
	AND	shift, and go to state 164
	BINOP	shift, and go to state 165
	CAT	shift, and go to state 167
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169
	OR	shift, and go to state 166

	'$'	reduce using rule 157 (assign)
	'${'	reduce using rule 157 (assign)
	';'	reduce using rule 157 (assign)
	COMMA	reduce using rule 157 (assign)
	IDENT	reduce using rule 157 (assign)
	LITERAL	reduce using rule 157 (assign)
	$default	reduce using rule 27 (atomexpr)

State 202:

	mdir -> directive .	(Rule 99)

	$default	reduce using rule 99 (mdir)

State 203:

	macro -> MACRO IDENT mdir .	(Rule 98)

	$default	reduce using rule 98 (macro)

State 204:

	macro -> MACRO IDENT '(' . margs ')' mdir	(Rule 97)
	expr -> '(' . assign ')'	(Rule 151)
	expr -> '(' . expr ')'	(Rule 152)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 277
	LITERAL	shift, and go to state 59
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 155
	sterm	go to state 71
	item	go to state 40
	assign	go to state 154
	margs	go to state 278
	node	go to state 24
	ident	go to state 153
	term	go to state 60
	lterm	go to state 58

State 205:

	atomexpr -> expr .	(Rule 27)
	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	'?'	shift, and go to state 162
	AND	shift, and go to state 164
	BINOP	shift, and go to state 165
	CAT	shift, and go to state 167
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169
	OR	shift, and go to state 166

	$default	reduce using rule 27 (atomexpr)

State 206:

	loopvar -> IDENT ASSIGN . term args	(Rule 69)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 279
	lterm	go to state 58

State 207:

	loopvar -> IDENT IN . term args	(Rule 70)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 280
	lterm	go to state 58

State 208:

	loopvar -> term args .	(Rule 71)
	args -> args . expr	(Rule 159)
	args -> args . param	(Rule 160)
	args -> args . ident ASSIGN expr	(Rule 161)
	args -> args . COMMA	(Rule 162)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	COMMA	shift, and go to state 266
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 264
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	$default	reduce using rule 71 (loopvar)

	expr	go to state 265
	sterm	go to state 71
	item	go to state 262
	param	go to state 263
	node	go to state 24
	ident	go to state 261
	term	go to state 60
	lterm	go to state 58

State 209:

	loop -> FOR loopvar ';' . @1-3 block END	(Rule 58)

	$default	reduce using rule 57 (@1-3)

	@1-3	go to state 281

State 210:

	lnameargs -> lvalue ASSIGN . nameargs	(Rule 164)

	'"'	shift, and go to state 91
	'$'	shift, and go to state 88
	FILENAME	shift, and go to state 85
	IDENT	shift, and go to state 83
	LITERAL	shift, and go to state 90
	NUMBER	shift, and go to state 86

	filepart	go to state 89
	names	go to state 93
	nameargs	go to state 282
	filename	go to state 87
	name	go to state 84

State 211:

	item -> IDENT .	(Rule 137)
	item -> '$' IDENT .	(Rule 139)

	ASSIGN	reduce using rule 139 (item)
	$default	reduce using rule 137 (item)

State 212:

	filter -> FILTER lnameargs ';' . block END	(Rule 87)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 3 (block)

	item	go to state 40
	loop	go to state 4
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 12
	atomdir	go to state 13
	anonblock	go to state 51
	defblockname	go to state 15
	bind	go to state 54
	ident	go to state 17
	assign	go to state 20
	macro	go to state 21
	lterm	go to state 58
	node	go to state 24
	term	go to state 60
	rawperl	go to state 61
	expr	go to state 64
	use	go to state 65
	defblock	go to state 68
	filter	go to state 30
	sterm	go to state 71
	perl	go to state 32
	chunks	go to state 34
	setlist	go to state 73
	switch	go to state 35
	try	go to state 36
	directive	go to state 74
	block	go to state 283
	condition	go to state 76

State 213:

	lvalue -> '"' quoted . '"'	(Rule 167)
	name -> '"' quoted . '"'	(Rule 174)
	quoted -> quoted . quotable	(Rule 182)

	'"'	shift, and go to state 284
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	';'	shift, and go to state 239
	IDENT	shift, and go to state 2
	TEXT	shift, and go to state 237

	item	go to state 40
	node	go to state 24
	ident	go to state 236
	quotable	go to state 238

State 214:

	anonblock -> BLOCK blockargs ';' . block END	(Rule 95)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 3 (block)

	item	go to state 40
	loop	go to state 4
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 12
	atomdir	go to state 13
	anonblock	go to state 51
	defblockname	go to state 15
	bind	go to state 54
	ident	go to state 17
	assign	go to state 20
	macro	go to state 21
	lterm	go to state 58
	node	go to state 24
	term	go to state 60
	rawperl	go to state 61
	expr	go to state 64
	use	go to state 65
	defblock	go to state 68
	filter	go to state 30
	sterm	go to state 71
	perl	go to state 32
	chunks	go to state 34
	setlist	go to state 73
	switch	go to state 35
	try	go to state 36
	directive	go to state 74
	block	go to state 285
	condition	go to state 76

State 215:

	lterm -> '{' hash '}' .	(Rule 115)

	$default	reduce using rule 115 (lterm)

State 216:

	param -> item ASSIGN . expr	(Rule 131)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 286
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 217:

	params -> params param .	(Rule 127)

	$default	reduce using rule 127 (params)

State 218:

	params -> params COMMA .	(Rule 128)

	$default	reduce using rule 128 (params)

State 219:

	param -> LITERAL ASSIGN . expr	(Rule 130)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 287
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 220:

	view -> VIEW nameargs ';' . @5-3 block END	(Rule 82)

	$default	reduce using rule 81 (@5-3)

	@5-3	go to state 288

State 221:

	item -> '${' sterm '}' .	(Rule 138)

	$default	reduce using rule 138 (item)

State 222:

	node -> item '(' args . ')'	(Rule 136)
	args -> args . expr	(Rule 159)
	args -> args . param	(Rule 160)
	args -> args . ident ASSIGN expr	(Rule 161)
	args -> args . COMMA	(Rule 162)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	')'	shift, and go to state 289
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	COMMA	shift, and go to state 266
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 264
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 265
	sterm	go to state 71
	item	go to state 262
	param	go to state 263
	node	go to state 24
	ident	go to state 261
	term	go to state 60
	lterm	go to state 58

State 223:

	perl -> PERL ';' @6-2 . block END	(Rule 84)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 3 (block)

	item	go to state 40
	loop	go to state 4
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 12
	atomdir	go to state 13
	anonblock	go to state 51
	defblockname	go to state 15
	bind	go to state 54
	ident	go to state 17
	assign	go to state 20
	macro	go to state 21
	lterm	go to state 58
	node	go to state 24
	term	go to state 60
	rawperl	go to state 61
	expr	go to state 64
	use	go to state 65
	defblock	go to state 68
	filter	go to state 30
	sterm	go to state 71
	perl	go to state 32
	chunks	go to state 34
	setlist	go to state 73
	switch	go to state 35
	try	go to state 36
	directive	go to state 74
	block	go to state 290
	condition	go to state 76

State 224:

	condition -> IF expr ';' . block else END	(Rule 45)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 3 (block)

	item	go to state 40
	loop	go to state 4
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 12
	atomdir	go to state 13
	anonblock	go to state 51
	defblockname	go to state 15
	bind	go to state 54
	ident	go to state 17
	assign	go to state 20
	macro	go to state 21
	lterm	go to state 58
	node	go to state 24
	term	go to state 60
	rawperl	go to state 61
	expr	go to state 64
	use	go to state 65
	defblock	go to state 68
	filter	go to state 30
	sterm	go to state 71
	perl	go to state 32
	chunks	go to state 34
	setlist	go to state 73
	switch	go to state 35
	try	go to state 36
	directive	go to state 74
	block	go to state 291
	condition	go to state 76

State 225:

	condition -> atomexpr UNLESS expr .	(Rule 48)
	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	'?'	shift, and go to state 162
	AND	shift, and go to state 164
	BINOP	shift, and go to state 165
	CAT	shift, and go to state 167
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169
	OR	shift, and go to state 166

	$default	reduce using rule 48 (condition)

State 226:

	loop -> atomexpr FOR loopvar .	(Rule 59)

	$default	reduce using rule 59 (loop)

State 227:

	filter -> atomexpr FILTER lnameargs .	(Rule 88)

	$default	reduce using rule 88 (filter)

State 228:

	condition -> atomexpr IF expr .	(Rule 46)
	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	'?'	shift, and go to state 162
	AND	shift, and go to state 164
	BINOP	shift, and go to state 165
	CAT	shift, and go to state 167
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169
	OR	shift, and go to state 166

	$default	reduce using rule 46 (condition)

State 229:

	wrapper -> atomexpr WRAPPER nameargs .	(Rule 73)

	$default	reduce using rule 73 (wrapper)

State 230:

	loop -> atomexpr WHILE expr .	(Rule 62)
	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	'?'	shift, and go to state 162
	AND	shift, and go to state 164
	BINOP	shift, and go to state 165
	CAT	shift, and go to state 167
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169
	OR	shift, and go to state 166

	$default	reduce using rule 62 (loop)

State 231:

	expr -> '(' assign ')' .	(Rule 151)

	$default	reduce using rule 151 (expr)

State 232:

	expr -> '(' expr ')' .	(Rule 152)

	$default	reduce using rule 152 (expr)

State 233:

	switch -> SWITCH expr ';' . block case END	(Rule 52)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 3 (block)

	item	go to state 40
	loop	go to state 4
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 12
	atomdir	go to state 13
	anonblock	go to state 51
	defblockname	go to state 15
	bind	go to state 54
	ident	go to state 17
	assign	go to state 20
	macro	go to state 21
	lterm	go to state 58
	node	go to state 24
	term	go to state 60
	rawperl	go to state 61
	expr	go to state 64
	use	go to state 65
	defblock	go to state 68
	filter	go to state 30
	sterm	go to state 71
	perl	go to state 32
	chunks	go to state 34
	setlist	go to state 73
	switch	go to state 35
	try	go to state 36
	directive	go to state 74
	block	go to state 292
	condition	go to state 76

State 234:

	wrapper -> WRAPPER nameargs ';' . block END	(Rule 72)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 3 (block)

	item	go to state 40
	loop	go to state 4
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 12
	atomdir	go to state 13
	anonblock	go to state 51
	defblockname	go to state 15
	bind	go to state 54
	ident	go to state 17
	assign	go to state 20
	macro	go to state 21
	lterm	go to state 58
	node	go to state 24
	term	go to state 60
	rawperl	go to state 61
	expr	go to state 64
	use	go to state 65
	defblock	go to state 68
	filter	go to state 30
	sterm	go to state 71
	perl	go to state 32
	chunks	go to state 34
	setlist	go to state 73
	switch	go to state 35
	try	go to state 36
	directive	go to state 74
	block	go to state 293
	condition	go to state 76

State 235:

	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)
	assign -> LITERAL ASSIGN expr .	(Rule 158)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	'?'	shift, and go to state 162
	AND	shift, and go to state 164
	BINOP	shift, and go to state 165
	CAT	shift, and go to state 167
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169
	OR	shift, and go to state 166

	$default	reduce using rule 158 (assign)

State 236:

	ident -> ident . DOT node	(Rule 132)
	ident -> ident . DOT NUMBER	(Rule 133)
	quotable -> ident .	(Rule 184)

	DOT	shift, and go to state 108

	$default	reduce using rule 184 (quotable)

State 237:

	quotable -> TEXT .	(Rule 185)

	$default	reduce using rule 185 (quotable)

State 238:

	quoted -> quoted quotable .	(Rule 182)

	$default	reduce using rule 182 (quoted)

State 239:

	quotable -> ';' .	(Rule 186)

	$default	reduce using rule 186 (quotable)

State 240:

	sterm -> '"' quoted '"' .	(Rule 118)

	$default	reduce using rule 118 (sterm)

State 241:

	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr '+' expr .	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)

	'/'	shift, and go to state 170
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169

	$default	reduce using rule 142 (expr)

State 242:

	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)
	expr -> expr '?' expr . ':' expr	(Rule 150)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	':'	shift, and go to state 294
	'?'	shift, and go to state 162
	AND	shift, and go to state 164
	BINOP	shift, and go to state 165
	CAT	shift, and go to state 167
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169
	OR	shift, and go to state 166

State 243:

	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr DIV expr .	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)

	MOD	shift, and go to state 169

	$default	reduce using rule 143 (expr)

State 244:

	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr AND expr .	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	BINOP	shift, and go to state 165
	CAT	shift, and go to state 167
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169

	$default	reduce using rule 147 (expr)

State 245:

	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr BINOP expr .	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169

	$default	reduce using rule 140 (expr)

State 246:

	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr OR expr .	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	BINOP	shift, and go to state 165
	CAT	shift, and go to state 167
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169

	$default	reduce using rule 148 (expr)

State 247:

	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr CAT expr .	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	BINOP	shift, and go to state 165
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169

	$default	reduce using rule 146 (expr)

State 248:

	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr CMPOP expr .	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	BINOP	shift, and go to state 165
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169

	$default	reduce using rule 145 (expr)

State 249:

	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr MOD expr .	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)

	$default	reduce using rule 144 (expr)

State 250:

	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr '/' expr .	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)

	DIV	shift, and go to state 163
	MOD	shift, and go to state 169

	$default	reduce using rule 141 (expr)

State 251:

	bind -> BINDING nameargs AROUND . ';' @3-4 block END	(Rule 64)

	';'	shift, and go to state 295

State 252:

	loop -> WHILE expr ';' . @2-3 block END	(Rule 61)

	$default	reduce using rule 60 (@2-3)

	@2-3	go to state 296

State 253:

	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)
	assign -> ident ASSIGN expr .	(Rule 157)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	'?'	shift, and go to state 162
	AND	shift, and go to state 164
	BINOP	shift, and go to state 165
	CAT	shift, and go to state 167
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169
	OR	shift, and go to state 166

	$default	reduce using rule 157 (assign)

State 254:

	condition -> UNLESS expr ';' block . else END	(Rule 47)

	ELSE	shift, and go to state 297
	ELSIF	shift, and go to state 299

	$default	reduce using rule 51 (else)

	else	go to state 298

State 255:

	filename -> filename DOT filepart .	(Rule 177)

	$default	reduce using rule 177 (filename)

State 256:

	args -> args . expr	(Rule 159)
	args -> args . param	(Rule 160)
	args -> args . ident ASSIGN expr	(Rule 161)
	args -> args . COMMA	(Rule 162)
	nameargs -> '$' ident args .	(Rule 169)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	COMMA	shift, and go to state 266
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 264
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	$default	reduce using rule 169 (nameargs)

	expr	go to state 265
	sterm	go to state 71
	item	go to state 262
	param	go to state 263
	node	go to state 24
	ident	go to state 261
	term	go to state 60
	lterm	go to state 58

State 257:

	name -> '"' quoted '"' .	(Rule 174)

	$default	reduce using rule 174 (name)

State 258:

	bind -> BIND nameargs AROUND ';' . @4-4 block END	(Rule 67)

	$default	reduce using rule 66 (@4-4)

	@4-4	go to state 300

State 259:

	names -> names '+' name .	(Rule 172)

	$default	reduce using rule 172 (names)

State 260:

	args -> args . expr	(Rule 159)
	args -> args . param	(Rule 160)
	args -> args . ident ASSIGN expr	(Rule 161)
	args -> args . COMMA	(Rule 162)
	nameargs -> names '(' args . ')'	(Rule 171)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	')'	shift, and go to state 301
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	COMMA	shift, and go to state 266
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 264
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 265
	sterm	go to state 71
	item	go to state 262
	param	go to state 263
	node	go to state 24
	ident	go to state 261
	term	go to state 60
	lterm	go to state 58

State 261:

	sterm -> ident .	(Rule 116)
	ident -> ident . DOT node	(Rule 132)
	ident -> ident . DOT NUMBER	(Rule 133)
	args -> args ident . ASSIGN expr	(Rule 161)

	ASSIGN	shift, and go to state 302
	DOT	shift, and go to state 108

	$default	reduce using rule 116 (sterm)

State 262:

	param -> item . ASSIGN expr	(Rule 131)
	node -> item .	(Rule 135)
	node -> item . '(' args ')'	(Rule 136)

	'('	shift, and go to state 139
	ASSIGN	shift, and go to state 216

	'('	[reduce using rule 135 (node)]
	ASSIGN	[reduce using rule 135 (node)]
	$default	reduce using rule 135 (node)

State 263:

	args -> args param .	(Rule 160)

	$default	reduce using rule 160 (args)

State 264:

	sterm -> LITERAL .	(Rule 119)
	param -> LITERAL . ASSIGN expr	(Rule 130)

	ASSIGN	shift, and go to state 219

	$default	reduce using rule 119 (sterm)

State 265:

	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)
	args -> args expr .	(Rule 159)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	'?'	shift, and go to state 162
	AND	shift, and go to state 164
	BINOP	shift, and go to state 165
	CAT	shift, and go to state 167
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169
	OR	shift, and go to state 166

	$default	reduce using rule 159 (args)

State 266:

	args -> args COMMA .	(Rule 162)

	$default	reduce using rule 162 (args)

State 267:

	range -> sterm TO sterm .	(Rule 124)

	$default	reduce using rule 124 (range)

State 268:

	final -> FINAL . ';' block	(Rule 78)

	';'	shift, and go to state 303

State 269:

	try -> TRY ';' block final . END	(Rule 74)

	END	shift, and go to state 304

State 270:

	final -> CATCH . filename ';' block final	(Rule 75)
	final -> CATCH . DEFAULT ';' block final	(Rule 76)
	final -> CATCH . ';' block final	(Rule 77)

	';'	shift, and go to state 306
	DEFAULT	shift, and go to state 307
	FILENAME	shift, and go to state 85
	IDENT	shift, and go to state 83
	NUMBER	shift, and go to state 86

	filepart	go to state 89
	filename	go to state 305

State 271:

	rawperl -> RAWPERL @7-1 ';' TEXT . END	(Rule 86)

	END	shift, and go to state 308

State 272:

	meta -> IDENT ASSIGN NUMBER .	(Rule 109)

	$default	reduce using rule 109 (meta)

State 273:

	meta -> IDENT ASSIGN LITERAL .	(Rule 107)

	$default	reduce using rule 107 (meta)

State 274:

	meta -> IDENT ASSIGN '"' . TEXT '"'	(Rule 108)

	TEXT	shift, and go to state 309

State 275:

	defblock -> defblockname blockargs ';' template . END	(Rule 89)

	END	shift, and go to state 310

State 276:

	mdir -> BLOCK ';' . block END	(Rule 100)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 3 (block)

	item	go to state 40
	loop	go to state 4
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 12
	atomdir	go to state 13
	anonblock	go to state 51
	defblockname	go to state 15
	bind	go to state 54
	ident	go to state 17
	assign	go to state 20
	macro	go to state 21
	lterm	go to state 58
	node	go to state 24
	term	go to state 60
	rawperl	go to state 61
	expr	go to state 64
	use	go to state 65
	defblock	go to state 68
	filter	go to state 30
	sterm	go to state 71
	perl	go to state 32
	chunks	go to state 34
	setlist	go to state 73
	switch	go to state 35
	try	go to state 36
	directive	go to state 74
	block	go to state 311
	condition	go to state 76

State 277:

	margs -> IDENT .	(Rule 103)
	item -> IDENT .	(Rule 137)

	')'	[reduce using rule 137 (item)]
	')'	reduce using rule 103 (margs)
	COMMA	reduce using rule 103 (margs)
	IDENT	reduce using rule 103 (margs)
	$default	reduce using rule 137 (item)

State 278:

	macro -> MACRO IDENT '(' margs . ')' mdir	(Rule 97)
	margs -> margs . IDENT	(Rule 101)
	margs -> margs . COMMA	(Rule 102)

	')'	shift, and go to state 313
	COMMA	shift, and go to state 314
	IDENT	shift, and go to state 312

State 279:

	loopvar -> IDENT ASSIGN term . args	(Rule 69)

	$default	reduce using rule 163 (args)

	args	go to state 315

State 280:

	loopvar -> IDENT IN term . args	(Rule 70)

	$default	reduce using rule 163 (args)

	args	go to state 316

State 281:

	loop -> FOR loopvar ';' @1-3 . block END	(Rule 58)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 3 (block)

	item	go to state 40
	loop	go to state 4
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 12
	atomdir	go to state 13
	anonblock	go to state 51
	defblockname	go to state 15
	bind	go to state 54
	ident	go to state 17
	assign	go to state 20
	macro	go to state 21
	lterm	go to state 58
	node	go to state 24
	term	go to state 60
	rawperl	go to state 61
	expr	go to state 64
	use	go to state 65
	defblock	go to state 68
	filter	go to state 30
	sterm	go to state 71
	perl	go to state 32
	chunks	go to state 34
	setlist	go to state 73
	switch	go to state 35
	try	go to state 36
	directive	go to state 74
	block	go to state 317
	condition	go to state 76

State 282:

	lnameargs -> lvalue ASSIGN nameargs .	(Rule 164)

	$default	reduce using rule 164 (lnameargs)

State 283:

	filter -> FILTER lnameargs ';' block . END	(Rule 87)

	END	shift, and go to state 318

State 284:

	lvalue -> '"' quoted '"' .	(Rule 167)
	name -> '"' quoted '"' .	(Rule 174)

	ASSIGN	reduce using rule 167 (lvalue)
	$default	reduce using rule 174 (name)

State 285:

	anonblock -> BLOCK blockargs ';' block . END	(Rule 95)

	END	shift, and go to state 319

State 286:

	param -> item ASSIGN expr .	(Rule 131)
	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	'?'	shift, and go to state 162
	AND	shift, and go to state 164
	BINOP	shift, and go to state 165
	CAT	shift, and go to state 167
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169
	OR	shift, and go to state 166

	$default	reduce using rule 131 (param)

State 287:

	param -> LITERAL ASSIGN expr .	(Rule 130)
	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	'?'	shift, and go to state 162
	AND	shift, and go to state 164
	BINOP	shift, and go to state 165
	CAT	shift, and go to state 167
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169
	OR	shift, and go to state 166

	$default	reduce using rule 130 (param)

State 288:

	view -> VIEW nameargs ';' @5-3 . block END	(Rule 82)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 3 (block)

	item	go to state 40
	loop	go to state 4
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 12
	atomdir	go to state 13
	anonblock	go to state 51
	defblockname	go to state 15
	bind	go to state 54
	ident	go to state 17
	assign	go to state 20
	macro	go to state 21
	lterm	go to state 58
	node	go to state 24
	term	go to state 60
	rawperl	go to state 61
	expr	go to state 64
	use	go to state 65
	defblock	go to state 68
	filter	go to state 30
	sterm	go to state 71
	perl	go to state 32
	chunks	go to state 34
	setlist	go to state 73
	switch	go to state 35
	try	go to state 36
	directive	go to state 74
	block	go to state 320
	condition	go to state 76

State 289:

	node -> item '(' args ')' .	(Rule 136)

	$default	reduce using rule 136 (node)

State 290:

	perl -> PERL ';' @6-2 block . END	(Rule 84)

	END	shift, and go to state 321

State 291:

	condition -> IF expr ';' block . else END	(Rule 45)

	ELSE	shift, and go to state 297
	ELSIF	shift, and go to state 299

	$default	reduce using rule 51 (else)

	else	go to state 322

State 292:

	switch -> SWITCH expr ';' block . case END	(Rule 52)

	CASE	shift, and go to state 323

	$default	reduce using rule 56 (case)

	case	go to state 324

State 293:

	wrapper -> WRAPPER nameargs ';' block . END	(Rule 72)

	END	shift, and go to state 325

State 294:

	expr -> expr '?' expr ':' . expr	(Rule 150)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 326
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 295:

	bind -> BINDING nameargs AROUND ';' . @3-4 block END	(Rule 64)

	$default	reduce using rule 63 (@3-4)

	@3-4	go to state 327

State 296:

	loop -> WHILE expr ';' @2-3 . block END	(Rule 61)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 3 (block)

	item	go to state 40
	loop	go to state 4
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 12
	atomdir	go to state 13
	anonblock	go to state 51
	defblockname	go to state 15
	bind	go to state 54
	ident	go to state 17
	assign	go to state 20
	macro	go to state 21
	lterm	go to state 58
	node	go to state 24
	term	go to state 60
	rawperl	go to state 61
	expr	go to state 64
	use	go to state 65
	defblock	go to state 68
	filter	go to state 30
	sterm	go to state 71
	perl	go to state 32
	chunks	go to state 34
	setlist	go to state 73
	switch	go to state 35
	try	go to state 36
	directive	go to state 74
	block	go to state 328
	condition	go to state 76

State 297:

	else -> ELSE . ';' block	(Rule 50)

	';'	shift, and go to state 329

State 298:

	condition -> UNLESS expr ';' block else . END	(Rule 47)

	END	shift, and go to state 330

State 299:

	else -> ELSIF . expr ';' block else	(Rule 49)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 331
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 300:

	bind -> BIND nameargs AROUND ';' @4-4 . block END	(Rule 67)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 3 (block)

	item	go to state 40
	loop	go to state 4
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 12
	atomdir	go to state 13
	anonblock	go to state 51
	defblockname	go to state 15
	bind	go to state 54
	ident	go to state 17
	assign	go to state 20
	macro	go to state 21
	lterm	go to state 58
	node	go to state 24
	term	go to state 60
	rawperl	go to state 61
	expr	go to state 64
	use	go to state 65
	defblock	go to state 68
	filter	go to state 30
	sterm	go to state 71
	perl	go to state 32
	chunks	go to state 34
	setlist	go to state 73
	switch	go to state 35
	try	go to state 36
	directive	go to state 74
	block	go to state 332
	condition	go to state 76

State 301:

	nameargs -> names '(' args ')' .	(Rule 171)

	$default	reduce using rule 171 (nameargs)

State 302:

	args -> args ident ASSIGN . expr	(Rule 161)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	expr	go to state 333
	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 60
	lterm	go to state 58

State 303:

	final -> FINAL ';' . block	(Rule 78)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 3 (block)

	item	go to state 40
	loop	go to state 4
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 12
	atomdir	go to state 13
	anonblock	go to state 51
	defblockname	go to state 15
	bind	go to state 54
	ident	go to state 17
	assign	go to state 20
	macro	go to state 21
	lterm	go to state 58
	node	go to state 24
	term	go to state 60
	rawperl	go to state 61
	expr	go to state 64
	use	go to state 65
	defblock	go to state 68
	filter	go to state 30
	sterm	go to state 71
	perl	go to state 32
	chunks	go to state 34
	setlist	go to state 73
	switch	go to state 35
	try	go to state 36
	directive	go to state 74
	block	go to state 334
	condition	go to state 76

State 304:

	try -> TRY ';' block final END .	(Rule 74)

	$default	reduce using rule 74 (try)

State 305:

	final -> CATCH filename . ';' block final	(Rule 75)
	filename -> filename . DOT filepart	(Rule 177)

	';'	shift, and go to state 335
	DOT	shift, and go to state 179

State 306:

	final -> CATCH ';' . block final	(Rule 77)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 3 (block)

	item	go to state 40
	loop	go to state 4
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 12
	atomdir	go to state 13
	anonblock	go to state 51
	defblockname	go to state 15
	bind	go to state 54
	ident	go to state 17
	assign	go to state 20
	macro	go to state 21
	lterm	go to state 58
	node	go to state 24
	term	go to state 60
	rawperl	go to state 61
	expr	go to state 64
	use	go to state 65
	defblock	go to state 68
	filter	go to state 30
	sterm	go to state 71
	perl	go to state 32
	chunks	go to state 34
	setlist	go to state 73
	switch	go to state 35
	try	go to state 36
	directive	go to state 74
	block	go to state 336
	condition	go to state 76

State 307:

	final -> CATCH DEFAULT . ';' block final	(Rule 76)

	';'	shift, and go to state 337

State 308:

	rawperl -> RAWPERL @7-1 ';' TEXT END .	(Rule 86)

	$default	reduce using rule 86 (rawperl)

State 309:

	meta -> IDENT ASSIGN '"' TEXT . '"'	(Rule 108)

	'"'	shift, and go to state 338

State 310:

	defblock -> defblockname blockargs ';' template END .	(Rule 89)

	$default	reduce using rule 89 (defblock)

State 311:

	mdir -> BLOCK ';' block . END	(Rule 100)

	END	shift, and go to state 339

State 312:

	margs -> margs IDENT .	(Rule 101)

	$default	reduce using rule 101 (margs)

State 313:

	macro -> MACRO IDENT '(' margs ')' . mdir	(Rule 97)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 199
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	item	go to state 40
	node	go to state 24
	term	go to state 60
	loop	go to state 4
	expr	go to state 205
	wrapper	go to state 47
	atomexpr	go to state 49
	atomdir	go to state 13
	mdir	go to state 340
	sterm	go to state 71
	filter	go to state 30
	bind	go to state 54
	ident	go to state 153
	perl	go to state 32
	setlist	go to state 73
	try	go to state 36
	switch	go to state 35
	assign	go to state 20
	directive	go to state 202
	condition	go to state 76
	lterm	go to state 58

State 314:

	margs -> margs COMMA .	(Rule 102)

	$default	reduce using rule 102 (margs)

State 315:

	loopvar -> IDENT ASSIGN term args .	(Rule 69)
	args -> args . expr	(Rule 159)
	args -> args . param	(Rule 160)
	args -> args . ident ASSIGN expr	(Rule 161)
	args -> args . COMMA	(Rule 162)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	COMMA	shift, and go to state 266
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 264
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	$default	reduce using rule 69 (loopvar)

	expr	go to state 265
	sterm	go to state 71
	item	go to state 262
	param	go to state 263
	node	go to state 24
	ident	go to state 261
	term	go to state 60
	lterm	go to state 58

State 316:

	loopvar -> IDENT IN term args .	(Rule 70)
	args -> args . expr	(Rule 159)
	args -> args . param	(Rule 160)
	args -> args . ident ASSIGN expr	(Rule 161)
	args -> args . COMMA	(Rule 162)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	COMMA	shift, and go to state 266
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 264
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	$default	reduce using rule 70 (loopvar)

	expr	go to state 265
	sterm	go to state 71
	item	go to state 262
	param	go to state 263
	node	go to state 24
	ident	go to state 261
	term	go to state 60
	lterm	go to state 58

State 317:

	loop -> FOR loopvar ';' @1-3 block . END	(Rule 58)

	END	shift, and go to state 341

State 318:

	filter -> FILTER lnameargs ';' block END .	(Rule 87)

	$default	reduce using rule 87 (filter)

State 319:

	anonblock -> BLOCK blockargs ';' block END .	(Rule 95)

	$default	reduce using rule 95 (anonblock)

State 320:

	view -> VIEW nameargs ';' @5-3 block . END	(Rule 82)

	END	shift, and go to state 342

State 321:

	perl -> PERL ';' @6-2 block END .	(Rule 84)

	$default	reduce using rule 84 (perl)

State 322:

	condition -> IF expr ';' block else . END	(Rule 45)

	END	shift, and go to state 343

State 323:

	case -> CASE . term ';' block case	(Rule 53)
	case -> CASE . DEFAULT ';' block	(Rule 54)
	case -> CASE . ';' block	(Rule 55)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	';'	shift, and go to state 344
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	DEFAULT	shift, and go to state 346
	IDENT	shift, and go to state 2
	LITERAL	shift, and go to state 81
	NUMBER	shift, and go to state 27
	REF	shift, and go to state 28

	sterm	go to state 71
	item	go to state 40
	node	go to state 24
	ident	go to state 80
	term	go to state 345
	lterm	go to state 58

State 324:

	switch -> SWITCH expr ';' block case . END	(Rule 52)

	END	shift, and go to state 347

State 325:

	wrapper -> WRAPPER nameargs ';' block END .	(Rule 72)

	$default	reduce using rule 72 (wrapper)

State 326:

	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)
	expr -> expr '?' expr ':' expr .	(Rule 150)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	'?'	shift, and go to state 162
	AND	shift, and go to state 164
	BINOP	shift, and go to state 165
	CAT	shift, and go to state 167
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169
	OR	shift, and go to state 166

	$default	reduce using rule 150 (expr)

State 327:

	bind -> BINDING nameargs AROUND ';' @3-4 . block END	(Rule 64)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 3 (block)

	item	go to state 40
	loop	go to state 4
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 12
	atomdir	go to state 13
	anonblock	go to state 51
	defblockname	go to state 15
	bind	go to state 54
	ident	go to state 17
	assign	go to state 20
	macro	go to state 21
	lterm	go to state 58
	node	go to state 24
	term	go to state 60
	rawperl	go to state 61
	expr	go to state 64
	use	go to state 65
	defblock	go to state 68
	filter	go to state 30
	sterm	go to state 71
	perl	go to state 32
	chunks	go to state 34
	setlist	go to state 73
	switch	go to state 35
	try	go to state 36
	directive	go to state 74
	block	go to state 348
	condition	go to state 76

State 328:

	loop -> WHILE expr ';' @2-3 block . END	(Rule 61)

	END	shift, and go to state 349

State 329:

	else -> ELSE ';' . block	(Rule 50)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 3 (block)

	item	go to state 40
	loop	go to state 4
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 12
	atomdir	go to state 13
	anonblock	go to state 51
	defblockname	go to state 15
	bind	go to state 54
	ident	go to state 17
	assign	go to state 20
	macro	go to state 21
	lterm	go to state 58
	node	go to state 24
	term	go to state 60
	rawperl	go to state 61
	expr	go to state 64
	use	go to state 65
	defblock	go to state 68
	filter	go to state 30
	sterm	go to state 71
	perl	go to state 32
	chunks	go to state 34
	setlist	go to state 73
	switch	go to state 35
	try	go to state 36
	directive	go to state 74
	block	go to state 350
	condition	go to state 76

State 330:

	condition -> UNLESS expr ';' block else END .	(Rule 47)

	$default	reduce using rule 47 (condition)

State 331:

	else -> ELSIF expr . ';' block else	(Rule 49)
	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	';'	shift, and go to state 351
	'?'	shift, and go to state 162
	AND	shift, and go to state 164
	BINOP	shift, and go to state 165
	CAT	shift, and go to state 167
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169
	OR	shift, and go to state 166

State 332:

	bind -> BIND nameargs AROUND ';' @4-4 block . END	(Rule 67)

	END	shift, and go to state 352

State 333:

	expr -> expr . BINOP expr	(Rule 140)
	expr -> expr . '/' expr	(Rule 141)
	expr -> expr . '+' expr	(Rule 142)
	expr -> expr . DIV expr	(Rule 143)
	expr -> expr . MOD expr	(Rule 144)
	expr -> expr . CMPOP expr	(Rule 145)
	expr -> expr . CAT expr	(Rule 146)
	expr -> expr . AND expr	(Rule 147)
	expr -> expr . OR expr	(Rule 148)
	expr -> expr . '?' expr ':' expr	(Rule 150)
	args -> args ident ASSIGN expr .	(Rule 161)

	'+'	shift, and go to state 161
	'/'	shift, and go to state 170
	'?'	shift, and go to state 162
	AND	shift, and go to state 164
	BINOP	shift, and go to state 165
	CAT	shift, and go to state 167
	CMPOP	shift, and go to state 168
	DIV	shift, and go to state 163
	MOD	shift, and go to state 169
	OR	shift, and go to state 166

	$default	reduce using rule 161 (args)

State 334:

	final -> FINAL ';' block .	(Rule 78)

	$default	reduce using rule 78 (final)

State 335:

	final -> CATCH filename ';' . block final	(Rule 75)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 3 (block)

	item	go to state 40
	loop	go to state 4
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 12
	atomdir	go to state 13
	anonblock	go to state 51
	defblockname	go to state 15
	bind	go to state 54
	ident	go to state 17
	assign	go to state 20
	macro	go to state 21
	lterm	go to state 58
	node	go to state 24
	term	go to state 60
	rawperl	go to state 61
	expr	go to state 64
	use	go to state 65
	defblock	go to state 68
	filter	go to state 30
	sterm	go to state 71
	perl	go to state 32
	chunks	go to state 34
	setlist	go to state 73
	switch	go to state 35
	try	go to state 36
	directive	go to state 74
	block	go to state 353
	condition	go to state 76

State 336:

	final -> CATCH ';' block . final	(Rule 77)

	CATCH	shift, and go to state 270
	FINAL	shift, and go to state 268

	$default	reduce using rule 79 (final)

	final	go to state 354

State 337:

	final -> CATCH DEFAULT ';' . block final	(Rule 76)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 3 (block)

	item	go to state 40
	loop	go to state 4
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 12
	atomdir	go to state 13
	anonblock	go to state 51
	defblockname	go to state 15
	bind	go to state 54
	ident	go to state 17
	assign	go to state 20
	macro	go to state 21
	lterm	go to state 58
	node	go to state 24
	term	go to state 60
	rawperl	go to state 61
	expr	go to state 64
	use	go to state 65
	defblock	go to state 68
	filter	go to state 30
	sterm	go to state 71
	perl	go to state 32
	chunks	go to state 34
	setlist	go to state 73
	switch	go to state 35
	try	go to state 36
	directive	go to state 74
	block	go to state 355
	condition	go to state 76

State 338:

	meta -> IDENT ASSIGN '"' TEXT '"' .	(Rule 108)

	$default	reduce using rule 108 (meta)

State 339:

	mdir -> BLOCK ';' block END .	(Rule 100)

	$default	reduce using rule 100 (mdir)

State 340:

	macro -> MACRO IDENT '(' margs ')' mdir .	(Rule 97)

	$default	reduce using rule 97 (macro)

State 341:

	loop -> FOR loopvar ';' @1-3 block END .	(Rule 58)

	$default	reduce using rule 58 (loop)

State 342:

	view -> VIEW nameargs ';' @5-3 block END .	(Rule 82)

	$default	reduce using rule 82 (view)

State 343:

	condition -> IF expr ';' block else END .	(Rule 45)

	$default	reduce using rule 45 (condition)

State 344:

	case -> CASE ';' . block	(Rule 55)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 3 (block)

	item	go to state 40
	loop	go to state 4
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 12
	atomdir	go to state 13
	anonblock	go to state 51
	defblockname	go to state 15
	bind	go to state 54
	ident	go to state 17
	assign	go to state 20
	macro	go to state 21
	lterm	go to state 58
	node	go to state 24
	term	go to state 60
	rawperl	go to state 61
	expr	go to state 64
	use	go to state 65
	defblock	go to state 68
	filter	go to state 30
	sterm	go to state 71
	perl	go to state 32
	chunks	go to state 34
	setlist	go to state 73
	switch	go to state 35
	try	go to state 36
	directive	go to state 74
	block	go to state 356
	condition	go to state 76

State 345:

	case -> CASE term . ';' block case	(Rule 53)

	';'	shift, and go to state 357

State 346:

	case -> CASE DEFAULT . ';' block	(Rule 54)

	';'	shift, and go to state 358

State 347:

	switch -> SWITCH expr ';' block case END .	(Rule 52)

	$default	reduce using rule 52 (switch)

State 348:

	bind -> BINDING nameargs AROUND ';' @3-4 block . END	(Rule 64)

	END	shift, and go to state 359

State 349:

	loop -> WHILE expr ';' @2-3 block END .	(Rule 61)

	$default	reduce using rule 61 (loop)

State 350:

	else -> ELSE ';' block .	(Rule 50)

	$default	reduce using rule 50 (else)

State 351:

	else -> ELSIF expr ';' . block else	(Rule 49)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 3 (block)

	item	go to state 40
	loop	go to state 4
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 12
	atomdir	go to state 13
	anonblock	go to state 51
	defblockname	go to state 15
	bind	go to state 54
	ident	go to state 17
	assign	go to state 20
	macro	go to state 21
	lterm	go to state 58
	node	go to state 24
	term	go to state 60
	rawperl	go to state 61
	expr	go to state 64
	use	go to state 65
	defblock	go to state 68
	filter	go to state 30
	sterm	go to state 71
	perl	go to state 32
	chunks	go to state 34
	setlist	go to state 73
	switch	go to state 35
	try	go to state 36
	directive	go to state 74
	block	go to state 360
	condition	go to state 76

State 352:

	bind -> BIND nameargs AROUND ';' @4-4 block END .	(Rule 67)

	$default	reduce using rule 67 (bind)

State 353:

	final -> CATCH filename ';' block . final	(Rule 75)

	CATCH	shift, and go to state 270
	FINAL	shift, and go to state 268

	$default	reduce using rule 79 (final)

	final	go to state 361

State 354:

	final -> CATCH ';' block final .	(Rule 77)

	$default	reduce using rule 77 (final)

State 355:

	final -> CATCH DEFAULT ';' block . final	(Rule 76)

	CATCH	shift, and go to state 270
	FINAL	shift, and go to state 268

	$default	reduce using rule 79 (final)

	final	go to state 362

State 356:

	case -> CASE ';' block .	(Rule 55)

	$default	reduce using rule 55 (case)

State 357:

	case -> CASE term ';' . block case	(Rule 53)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 3 (block)

	item	go to state 40
	loop	go to state 4
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 12
	atomdir	go to state 13
	anonblock	go to state 51
	defblockname	go to state 15
	bind	go to state 54
	ident	go to state 17
	assign	go to state 20
	macro	go to state 21
	lterm	go to state 58
	node	go to state 24
	term	go to state 60
	rawperl	go to state 61
	expr	go to state 64
	use	go to state 65
	defblock	go to state 68
	filter	go to state 30
	sterm	go to state 71
	perl	go to state 32
	chunks	go to state 34
	setlist	go to state 73
	switch	go to state 35
	try	go to state 36
	directive	go to state 74
	block	go to state 363
	condition	go to state 76

State 358:

	case -> CASE DEFAULT ';' . block	(Rule 54)

	'"'	shift, and go to state 62
	'$'	shift, and go to state 44
	'${'	shift, and go to state 38
	'('	shift, and go to state 55
	'['	shift, and go to state 10
	'{'	shift, and go to state 31
	BIND	shift, and go to state 5
	BINDING	shift, and go to state 69
	BLOCK	shift, and go to state 29
	CALL	shift, and go to state 46
	CLEAR	shift, and go to state 42
	DEBUG	shift, and go to state 52
	DEFAULT	shift, and go to state 72
	FILTER	shift, and go to state 26
	FOR	shift, and go to state 22
	GET	shift, and go to state 48
	IDENT	shift, and go to state 2
	IF	shift, and go to state 45
	INCLUDE	shift, and go to state 18
	INSERT	shift, and go to state 67
	LAST	shift, and go to state 50
	LITERAL	shift, and go to state 59
	MACRO	shift, and go to state 19
	META	shift, and go to state 16
	NEXT	shift, and go to state 23
	NOT	shift, and go to state 39
	NUMBER	shift, and go to state 27
	PERL	shift, and go to state 41
	PROCESS	shift, and go to state 63
	RAWPERL	shift, and go to state 14
	REF	shift, and go to state 28
	RETURN	shift, and go to state 66
	SET	shift, and go to state 1
	STOP	shift, and go to state 7
	SWITCH	shift, and go to state 56
	TEXT	shift, and go to state 25
	THROW	shift, and go to state 9
	TRY	shift, and go to state 11
	UNLESS	shift, and go to state 3
	USE	shift, and go to state 33
	VIEW	shift, and go to state 37
	WHILE	shift, and go to state 70
	WRAPPER	shift, and go to state 57

	';'	reduce using rule 18 (statement)
	$default	reduce using rule 3 (block)

	item	go to state 40
	loop	go to state 4
	capture	go to state 43
	statement	go to state 6
	view	go to state 8
	wrapper	go to state 47
	atomexpr	go to state 49
	chunk	go to state 12
	atomdir	go to state 13
	anonblock	go to state 51
	defblockname	go to state 15
	bind	go to state 54
	ident	go to state 17
	assign	go to state 20
	macro	go to state 21
	lterm	go to state 58
	node	go to state 24
	term	go to state 60
	rawperl	go to state 61
	expr	go to state 64
	use	go to state 65
	defblock	go to state 68
	filter	go to state 30
	sterm	go to state 71
	perl	go to state 32
	chunks	go to state 34
	setlist	go to state 73
	switch	go to state 35
	try	go to state 36
	directive	go to state 74
	block	go to state 364
	condition	go to state 76

State 359:

	bind -> BINDING nameargs AROUND ';' @3-4 block END .	(Rule 64)

	$default	reduce using rule 64 (bind)

State 360:

	else -> ELSIF expr ';' block . else	(Rule 49)

	ELSE	shift, and go to state 297
	ELSIF	shift, and go to state 299

	$default	reduce using rule 51 (else)

	else	go to state 365

State 361:

	final -> CATCH filename ';' block final .	(Rule 75)

	$default	reduce using rule 75 (final)

State 362:

	final -> CATCH DEFAULT ';' block final .	(Rule 76)

	$default	reduce using rule 76 (final)

State 363:

	case -> CASE term ';' block . case	(Rule 53)

	CASE	shift, and go to state 323

	$default	reduce using rule 56 (case)

	case	go to state 366

State 364:

	case -> CASE DEFAULT ';' block .	(Rule 54)

	$default	reduce using rule 54 (case)

State 365:

	else -> ELSIF expr ';' block else .	(Rule 49)

	$default	reduce using rule 49 (else)

State 366:

	case -> CASE term ';' block case .	(Rule 53)

	$default	reduce using rule 53 (case)


Summary:
--------
Number of rules         : 187
Number of terminals     : 72
Number of non-terminals : 66
Number of states        : 367
